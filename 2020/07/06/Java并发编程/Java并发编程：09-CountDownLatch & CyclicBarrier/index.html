<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">





<title>Java并发编程：09-CountDownLatch &amp; CyclicBarrier | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.2.0"></head>
<!-- <a target="_blank" rel="noopener" href="https://github.com/networkcv" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style> -->
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Network Cavalry&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Network Cavalry&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Java并发编程：09-CountDownLatch &amp; CyclicBarrier</h1>
            
                <div class="post-meta">
                    

                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p><strong>前言：</strong></p>
<p>通过前面对Semaphore的学习，我们了解了AQS框架中共享模式下的基本流程，本篇再去看看另一种共享模式的实现——CountDownLatch，以及功能和它类似的CyclicBarrier。</p>
<p><strong>面试问题</strong></p>
<p>Q ：CountDownLatch 类中主要的方法？</p>
<p>Q ：CountDownLatch和CyclicBarrier的区别？</p>
<h2 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1.CountDownLatch"></a>1.CountDownLatch</h2><h3 id="1-1-CountDownLatch介绍"><a href="#1-1-CountDownLatch介绍" class="headerlink" title="1.1 CountDownLatch介绍"></a>1.1 CountDownLatch介绍</h3><p><strong>CountDownLatch</strong> ，闭锁，门闩，也可以理解为倒计时器。</p>
<p>比如有这样一个场景，火箭发射前需要确保各个部件正常，如果存在异常，则火箭无法发射。</p>
<p>使用多线程同时对火箭的各个部分进行检查，检查完毕后，主线程才会执行火箭发射操作。</p>
<p>火箭发射线程等待其他检查线程执行完毕，可以抽象为一个线程等待多个线程的场景。</p>
<p>在没有CountDownLatch的时候，我们可以通过定义一个倒计时器搭配synchronized和wait()&#x2F;notify()来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">countDown</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 检查完毕!&quot;</span>);</span><br><span class="line">                   countDown--;</span><br><span class="line">                   <span class="keyword">if</span> (countDown == <span class="number">0</span>) &#123;</span><br><span class="line">                       lock.notify();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, i + <span class="string">&quot;号线程&quot;</span>).start();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (countDown != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">               lock.wait();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;火箭发射！！&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>为了保证<code>countDown-- </code>操作的原子性，在线程检查的时候使用了synchronzied关键字进行加锁，如果不加锁的话，countDown可能会因为线程切换导致原子性问题，但是加锁之后，从多线程同时做检查变成了某一时刻只能有一个线程检查，无疑大大地降低了工作效率。有没有一个两全其美的办法？还真有，使用volatile就可以实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程不安全的</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">50000</span>;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 检查完毕!&quot;</span>);</span><br><span class="line">                state--;</span><br><span class="line">            &#125;, i + <span class="string">&quot;号线程&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (state != <span class="number">0</span>) &#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;火箭发射！！&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上边的代码有两个问题：</p>
<ol>
<li>虽然使用volatile修饰state，使其修改结果对其他线程可见，并且不会因为重排序导致导致线程安全问题，但是volatile不能保证<code>state--</code>操作的原子性，发生原子性问题时，会使countDown无法减为0，自然发射火箭的主线程也永远无法被唤醒。</li>
<li>主线程一直在不停的检查state有没有被减为0，这样会降低程序的性能。</li>
</ol>
<p>解决办法：</p>
<ol>
<li>使用CAS操作自旋来修改state，解决原子性问题。</li>
<li>先让主线程尝试一次，如果失败的话就挂起，进入等待状态，由将state修改为0的线程来唤醒它。</li>
</ol>
<p>如果你看了前边几篇文章，你会发现上边的逻辑很熟悉，AQS最根本的原理就是这样的，并且J.U.C中为了解决这类问题，已经帮我们做了实现——CountDownLatch。</p>
<h3 id="1-2-CountDownLatch使用"><a href="#1-2-CountDownLatch使用" class="headerlink" title="1.2 CountDownLatch使用"></a>1.2 CountDownLatch使用</h3><p>先来来看看CountDownLatch中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造初始的state值，可以执行state次countDown</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//等待直到被唤醒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待一段时间，超时自己醒</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对state进行-1    </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> </span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取当前的state    </span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCount</span><span class="params">()</span></span><br></pre></td></tr></table></figure>



<p><strong>使用方式</strong></p>
<p>CountDownLatch主要用来解决一个线程等待多个线程的场景。</p>
<p>下面使用CountDownLatch来实现火箭发射的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">CountDownLatch</span> <span class="variable">cdl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 检查完毕!&quot;</span>);</span><br><span class="line">               cdl.countDown();</span><br><span class="line">           &#125;, i + <span class="string">&quot;号线程&quot;</span>).start();</span><br><span class="line">       &#125;</span><br><span class="line">       cdl.await();</span><br><span class="line">       System.out.println(<span class="string">&quot;火箭发射！！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/*	Output</span></span><br><span class="line"><span class="comment">	1号线程 检查完毕!</span></span><br><span class="line"><span class="comment">       3号线程 检查完毕!</span></span><br><span class="line"><span class="comment">       4号线程 检查完毕!</span></span><br><span class="line"><span class="comment">       0号线程 检查完毕!</span></span><br><span class="line"><span class="comment">       2号线程 检查完毕!</span></span><br><span class="line"><span class="comment">       火箭发射！！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>countDown() </code>就是用CAS进行<code>state--</code> 减到0的线程会去通知等待在CountDownLatch上的节点，只通知首节点。</p>
<p><code>await()</code> 则是先尝试，尝试失败后进入等待队列，别唤醒后还会通知后边的节点，以此类推，以传播的方式唤醒等待队列中的所有节点。</p>
<p><strong>使用场景</strong></p>
<ol>
<li>前面提到了倒计时器的用法，本质上就是为了等其他线程执行完，可以用在启动服务时，等待其他组件的加载。</li>
<li>可以使多个线程同时开始执行，提供很大的并行性，这里更关注的是线程到齐之后。平时在主线程启动线程时，由于代码顺序执行的缘故，线程并不是真正同时start的，中间存在时间差，如果执行的耗时特别短，那么可能很多问题不会暴露出来。通过让多个先后启动的测试线程在CountDownLatch上进行等待，等到所有测试线程都启动完毕再统一释放。这里的CountDownLatch起到了和Thread.yield类似的作用，可以增大出现并发问题的几率。因此可以写多个线程来进行死锁的检测。</li>
</ol>
<h3 id="1-3-CountDownLatch原理"><a href="#1-3-CountDownLatch原理" class="headerlink" title="1.3 CountDownLatch原理"></a>1.3 CountDownLatch原理</h3><p>CountDownLatch的原理其实并不难，不难是建立对AQS有了解之上的。</p>
<p>在介绍时简单提了一下原理，下面看一看源码的实现细节吧。</p>
<p>构造设置state。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">       <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">       setState(count);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">       state = newState;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>await()</strong></p>
<p>这次我们看一个限时的尝试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将等待的时间转换为纳秒，调用 <code>tryAcquireSharedNanos(int arg, long nanosTimeout)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquireSharedNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</span><br><span class="line">        doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryAcquireShared()</code>只检查当前的state是否被减为0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点在 <code>doAcquireSharedNanos(arg, nanosTimeout)。</code><br>这个方法和Semphore中看过的<code>doAcquireShared(int arg)</code>很相像，不同在于该方法中加入了超时退出逻辑。这次我们关注于超时退出逻辑，想更深入了解该方法的，可以移步至 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021400650">Semaphore &amp; AQS</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doAcquireSharedNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//记录在哪个时间点超时</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">//添加到等待队列</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">//检查state是为0，是0返回1，不是返回-1</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//将当前节点设置为头节点，并向后唤醒</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否超时，超时则返回false</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//判断是否挂起当前线程，其实就是将前驱节点的waitStatus设置为SIGNAL</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">//如果要等待的时间小于1000L纳秒，则线程不会被挂起，</span></span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                <span class="comment">//挂起当前线程</span></span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>countDown()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CountDownLatch</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AQS   </span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CountDownLatch	</span></span><br><span class="line">	<span class="comment">//这个方法就是变相的保证了state--操作的原子性</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AQS </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="comment">//将头节点的waitStatus从SIGNAL设置为0</span></span><br><span class="line">                    <span class="comment">//不成功则自旋，成功会执行唤醒操作</span></span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    <span class="comment">//唤醒后继节点</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2.CyclicBarrier"></a>2.CyclicBarrier</h2><h3 id="2-1-CyclicBarrier介绍"><a href="#2-1-CyclicBarrier介绍" class="headerlink" title="2.1 CyclicBarrier介绍"></a>2.1 CyclicBarrier介绍</h3><p>通过前面的内容，我们大致了解了CountDownLatch的使用方法及使用场景。</p>
<p>现在模拟一个新的应用场景，LOL或者王者荣耀大家都玩过吧，在点了开始游戏按钮后，会进到一个等待队列中，系统根据匹配机制找到10个旗鼓相当的玩家，然后才正式开始游戏。</p>
<p>开始游戏的主线程需要等待计算玩家水平的10个线程完成后才执行，第一反应是使用CountDownLatch，但是CountDownLatch有个问题是只能使用一次，减到0后就没办法再修改state了，而在等待队列中的游戏玩家有很多，每10个玩家就需要创建一个CountDownLatch对象，这样可能会频繁GC，所以可以考虑复用倒计时器对象，减少对象创建销毁带来的性能损耗。</p>
<p>CountDownLatch还有一个问题是无法执行回调，比如之前那个火箭发射的场景，检查完毕后火箭自己就发射了，但是我们无法得知。如果完成检查后执行一个回调函数，来通知我们执行结果，那就好了。</p>
<p>这两点<strong>CyclicBarrier</strong>已经实现了。</p>
<ul>
<li>可以循环使用</li>
<li>可以执行回调函数</li>
</ul>
<p>CyclicBarrier字面意思循环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。当所有等待线程都被释放以后，CyclicBarrier可以被重用。并且最后一个到达的线程还会执行CyclicBarrier中的回调函数。</p>
<h3 id="2-2-CyclicBarrier使用"><a href="#2-2-CyclicBarrier使用" class="headerlink" title="2.2 CyclicBarrier使用"></a>2.2 CyclicBarrier使用</h3><p>先看构造，<code>parties</code>，是指parties个线程到达后栅栏才会打开一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> </span><br></pre></td></tr></table></figure>

<p><code>barrierAction</code>则是指当这些线程都到达后会执行的内容，具体是由最后一个到达的线程来执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName() + <span class="string">&quot; print all is ok&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is ok!&quot;</span>);</span><br><span class="line">                   barrier.await();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, i + <span class="string">&quot;号玩家&quot;</span>).start();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/*  Output</span></span><br><span class="line"><span class="comment">           1号玩家 is ok!</span></span><br><span class="line"><span class="comment">           3号玩家 is ok!</span></span><br><span class="line"><span class="comment">           2号玩家 is ok!</span></span><br><span class="line"><span class="comment">           0号玩家 is ok!</span></span><br><span class="line"><span class="comment">           4号玩家 is ok!</span></span><br><span class="line"><span class="comment">           4号玩家 print all is ok</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以被中断的等待操作，用来挂起当前线程，直至所有线程都到达再同时执行后续任务；　</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">               System.out.println(finalI + <span class="string">&quot; is ok!&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   barrier.await();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(finalI + <span class="string">&quot; 加入游戏&quot;</span>);</span><br><span class="line">           &#125;).start();</span><br><span class="line">       &#125;</span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/*  Output</span></span><br><span class="line"><span class="comment">           2 is ok!</span></span><br><span class="line"><span class="comment">           1 is ok!</span></span><br><span class="line"><span class="comment">           3 is ok!</span></span><br><span class="line"><span class="comment">           4 is ok!</span></span><br><span class="line"><span class="comment">           0 is ok!</span></span><br><span class="line"><span class="comment">           4 加入游戏</span></span><br><span class="line"><span class="comment">           0 加入游戏</span></span><br><span class="line"><span class="comment">           1 加入游戏</span></span><br><span class="line"><span class="comment">           3 加入游戏</span></span><br><span class="line"><span class="comment">           2 加入游戏</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>线程等待一段的时间后，如果还有线程没有到达，就直接让到达的线程执行后续任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;五个玩家到齐了，开始游戏&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is ok!&quot;</span>);</span><br><span class="line">                   barrier.await(<span class="number">100</span>,TimeUnit.MILLISECONDS);</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() +<span class="string">&quot; 开始游戏&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException | TimeoutException e) &#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 不等了&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, i + <span class="string">&quot;号玩家&quot;</span>).start();</span><br><span class="line">       &#125;</span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/*  Output</span></span><br><span class="line"><span class="comment">           0号玩家 is ok!</span></span><br><span class="line"><span class="comment">           1号玩家 is ok!</span></span><br><span class="line"><span class="comment">           2号玩家 is ok!</span></span><br><span class="line"><span class="comment">           3号玩家 is ok!</span></span><br><span class="line"><span class="comment">           3号玩家 不等了</span></span><br><span class="line"><span class="comment">           0号玩家 不等了</span></span><br><span class="line"><span class="comment">           2号玩家 不等了</span></span><br><span class="line"><span class="comment">           1号玩家 不等了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>主要使用的是上边这四个，下边还有四个其他方法：</p>
<p>返回当前在等待的线程数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumberWaiting</span><span class="params">()</span> </span><br></pre></td></tr></table></figure>

<p>返回该CyclicBarrier每批阻拦的最大线程数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getParties</span><span class="params">()</span> </span><br></pre></td></tr></table></figure>

<p>判断当前这一轮线程的屏障状态有没有被打破</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBroken</span><span class="params">()</span> </span><br></pre></td></tr></table></figure>

<p>强制重置屏障，使屏障进入新一轮的运行过程中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> </span><br></pre></td></tr></table></figure>





<h3 id="2-3-CyclicBarrier原理"><a href="#2-3-CyclicBarrier原理" class="headerlink" title="2.3 CyclicBarrier原理"></a>2.3 CyclicBarrier原理</h3><p>CyclicBarrier并没有直接使用AQS，而是借助ReentrantLock和Condition实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrier</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Generation</span> &#123;</span><br><span class="line">        <span class="comment">//记录屏障是否被破坏</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">broken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">trip</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程数，即当 parties 个线程到达屏障后，屏障才会放行。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> parties;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//回调方法，如果不为空的话，在将count减为0的线程中执行。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这一批线程的屏障状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Generation</span> <span class="variable">generation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计数器，当 count &gt; 0 时，到达屏障的线程会进入等待状态。当最后一个线程到达屏障后，</span></span><br><span class="line">    <span class="comment">//count 自减至0。最后一个到达的线程会执行回调方法，并唤醒其他处于等待状态中的线程。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>核心方法<code>await()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//参数timed 表示是否有等待时间限制，参数nanos 表示最大等待的纳秒数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">       <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">              TimeoutException &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">	<span class="comment">//为了保证 --count 操作的原子性，此时使用Lock加锁</span></span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line">	   <span class="comment">//如果屏障被破坏，则抛出异常，锁也会随之释放。</span></span><br><span class="line">           <span class="keyword">if</span> (g.broken)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line">		</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 如果当前线程被中断，会释放Condition上等待的线程，重置count</span></span><br><span class="line"><span class="comment">            * 将屏障状态设置为被破坏，并抛出中断异常</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">               breakBarrier();</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">           &#125;</span><br><span class="line">		</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * count--，如果当前线程将count减为0，则先执行回调方法，</span></span><br><span class="line"><span class="comment">            * 再去调用breakBarrier()来开启下一批拦截</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">           <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">               <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                   <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                       command.run();</span><br><span class="line">                   ranAction = <span class="literal">true</span>;</span><br><span class="line">                   nextGeneration();</span><br><span class="line">                   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                       breakBarrier();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!timed)</span><br><span class="line">                       trip.await();</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                       nanos = trip.awaitNanos(nanos);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * 若下面的条件成立，则表明本轮运行还未结束。此时调用 breakBarrier </span></span><br><span class="line"><span class="comment">                    * 破坏屏障，唤醒其他线程，并抛出异常</span></span><br><span class="line"><span class="comment">                    */</span> </span><br><span class="line">                   <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                       breakBarrier();</span><br><span class="line">                       <span class="keyword">throw</span> ie;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        * 若上面的条件不成立，则有两种可能：</span></span><br><span class="line"><span class="comment">                        * 1. g != generation</span></span><br><span class="line"><span class="comment">                        *     此种情况下，表明循环屏障的第 g 轮次的运行已经结束，屏障已经</span></span><br><span class="line"><span class="comment">                        *     进入了新的一轮运行轮次中。当前线程在稍后返回 到达屏障 的顺序即可</span></span><br><span class="line"><span class="comment">                        *     </span></span><br><span class="line"><span class="comment">                        * 2. g = generation 但 g.broken = true</span></span><br><span class="line"><span class="comment">                        *     此种情况下，表明已经有线程执行过 breakBarrier 方法了，当前</span></span><br><span class="line"><span class="comment">                        *     线程则会在稍后抛出 BrokenBarrierException</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                       Thread.currentThread().interrupt();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">			</span><br><span class="line">               <span class="comment">// 屏障被破坏，则抛出 BrokenBarrierException 异常</span></span><br><span class="line">               <span class="keyword">if</span> (g.broken)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line">		</span><br><span class="line">               <span class="comment">// 屏障进入新的运行轮次，此时返回线程在上一轮次到达屏障的顺序</span></span><br><span class="line">               <span class="keyword">if</span> (g != generation)</span><br><span class="line">                   <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 超时判断</span></span><br><span class="line">               <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                   breakBarrier();</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h3><p><code>CyclicBarrier</code> 内部通过一个 count 变量作为计数器，cout 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，先使用ReentrantLock加锁，再对计数器减一，随后在Lock的condition上挂起，如果 count 被减为 0 了，表示这是这一批最后一个线程到达栅栏，就在当前线程执行回调方法，并调用condition对象的<code>signalAll()</code>方法唤醒其他等待中的线程，一起执行后续的任务。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><h3 id="CyclicBarrier与CountDownLatch的比较"><a href="#CyclicBarrier与CountDownLatch的比较" class="headerlink" title="CyclicBarrier与CountDownLatch的比较"></a>CyclicBarrier与CountDownLatch的比较</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">CountDownLatch</th>
<th align="center">CyclicBarrier</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可循环使用</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">可设置回调</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
</tbody></table>
<p>CountDownLatch：一个或多个线程等待另外N个线程完成某个事情之后才能继续执行。</p>
<p>CyclicBarrier：N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。</p>
<p>CountDownLatch是计数器，线程完成一个就计一个，就像报数一样，只不过是递减的。<br>CyclicBarrier更像一个水闸，线程执行就像水流，在水闸处就会堵住，等到水满（线程到齐）了，才开始泄流。</p>
<p><strong>最后</strong></p>
<p>对J.U.C的学习到此暂时就结束了，后边遇到问题时，再回过头来看看，说不定有新的收获。</p>
<p>下面会对并发级别、无锁、同步容器、并发容器、线程池，以及多线程的设计模式等来进行学习总结。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>&emsp;&emsp;《Java 并发编程实战》<br>&emsp;&emsp;《Java 编程思想(第4版)》<br>&emsp;&emsp;<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/159">https://time.geekbang.org/column/intro/159</a><br>&emsp;&emsp;<a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/">https://snailclimb.gitee.io/javaguide/#/</a><br>&emsp;&emsp;<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3920397.html">https://www.cnblogs.com/dolphin0520/p/3920397.html</a></p>
<p><strong>感谢阅读</strong>！</p>

        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Java/"># Java</a>
                    
                        <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"># 并发编程</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/12/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A10-AQS/">Java并发编程：10-AQS</a>
            
            
            <a class="next" rel="next" href="/2020/07/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A08-Semaphore%20&%20AQS/">Java并发编程：08-Semaphore & AQS</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <!-- <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> -->
    <div class="copyright">
        <!-- <span> welcome~</a></span> -->
    </div>
    <!-- 访问统计 -->
    <!-- <div class="powered-by">
        <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
            welcome~ <span id="busuanzi_value_site_pv"></span>
        </span>
    </div> -->
</footer>

    </div>
</body>
</html>
