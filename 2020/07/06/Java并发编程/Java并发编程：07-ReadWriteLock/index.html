<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">





<title>Java并发编程：07-ReadWriteLock | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.2.0"></head>
<!-- <a target="_blank" rel="noopener" href="https://github.com/networkcv" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style> -->
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Network Cavalry&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Network Cavalry&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Java并发编程：07-ReadWriteLock</h1>
            
                <div class="post-meta">
                    

                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p><strong>前言：</strong></p>
<p>上一篇我们了解了Lock接口与Condition接口。本篇来看看J.U.C中的ReadWriteLock，再次膜拜一下Doug Lea大神的杰作。</p>
<p><strong>面试问题</strong><br>Q ：谈谈对ReadWriteLock的理解？</p>
<h2 id="1-ReadWriteLock简介"><a href="#1-ReadWriteLock简介" class="headerlink" title="1.ReadWriteLock简介"></a>1.ReadWriteLock简介</h2><p>ReadWriteLock接口是在JDK5提供的，具体的实现类为ReentrantReadWriteLock，还有一个实现类ReadWriteLockView，是StampedLock的内部类。后边会有讲到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReadWriteLock直译为读写锁，从接口命名上就可以看出该工具类用于特定的场景下，前面讲过的ReentrantLock和synchronized基本可以用来解决一切并发问题，但在特定的场景下可能表现的效果不那么令人满意，如在读多写少的时，大部分线程都在进行读操作，很少有线程会修改共享数据。但由于加锁的特性，导致大量的读操作进行了不必要的锁竞争，如果能将读写的锁分离，有写操作的时候，进行读操作需要加锁；没有写操作的时候，可以多个线程同时进行读操作。这样势必会提升性能。</p>
<p>读写锁便是解决这种场景问题的。读写锁有三个基本原则：</p>
<ol>
<li>允许多个线程同时读共享变量</li>
<li>只允许一个线程写共享变量</li>
<li>如果一个写线程正在执行，此时禁止读线程读共享变量，如果一个线程在读，同样也禁止写共享变量。</li>
</ol>
<h2 id="2-ReentrantReadWriteLock使用"><a href="#2-ReentrantReadWriteLock使用" class="headerlink" title="2.ReentrantReadWriteLock使用"></a>2.ReentrantReadWriteLock使用</h2><h3 id="2-1-锁降级"><a href="#2-1-锁降级" class="headerlink" title="2.1 锁降级"></a>2.1 锁降级</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock readWriteLock=<span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"><span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> readWriteLock.readLock()</span><br><span class="line"><span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> readWriteLock.writeLock()</span><br></pre></td></tr></table></figure>

<p>可以看出无论是读锁还是写锁都是Lock接口的实现类，那么上一篇中提到Lock接口的三种加锁方式都可以使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持中断的加锁</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">//支持超时的加锁</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">//支持非阻塞获取锁</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>Reentrant代表可重入的，ReentrantReadWriteLock支持重入锁，而且也支持公平锁和非公平锁。</p>
<hr>
<p>前面简单的介绍的读写锁的使用，这里有一个需要注意的点，就是读写锁的升级和降级。</p>
<p>ReentrantReadWriteLock<font color=Crimson>不支持锁的升级</font>，但是<font color=dodgerblue>支持锁的降级</font>。锁降级就是持有写锁去申请读锁；锁升级是持有读锁去申请写锁，如果出现类似锁升级的代码，则会导致线程阻塞，且无法被唤醒。这点需要注意。</p>
<p>锁的升级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">	<span class="type">ReentrantReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="comment">//无法进行锁的升级，从读变成写</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           readWriteLock.readLock().lock();</span><br><span class="line">           System.out.println(<span class="string">&quot;获取读锁&quot;</span>);</span><br><span class="line">           </span><br><span class="line">           readWriteLock.writeLock().lock();</span><br><span class="line">           System.out.println(<span class="string">&quot;获取写锁&quot;</span>);</span><br><span class="line">           </span><br><span class="line">           readWriteLock.writeLock().unlock();</span><br><span class="line">           System.out.println(<span class="string">&quot;释放写锁&quot;</span>);</span><br><span class="line">           </span><br><span class="line">           readWriteLock.readLock().unlock();</span><br><span class="line">           System.out.println(<span class="string">&quot;释放读锁&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       thread.start();</span><br><span class="line">       thread.join();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/*Output</span></span><br><span class="line"><span class="comment">       获取读锁</span></span><br><span class="line"><span class="comment">       ----- 发生阻塞----- 必须先释放读锁才能去申请写锁，不然会阻塞</span></span><br></pre></td></tr></table></figure>

<p>锁的降级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">ReentrantReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="comment">//进行锁的降级，从写变成读</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           readWriteLock.writeLock().lock();</span><br><span class="line">           System.out.println(<span class="string">&quot;获取写锁&quot;</span>);</span><br><span class="line">           </span><br><span class="line">           readWriteLock.readLock().lock();</span><br><span class="line">           System.out.println(<span class="string">&quot;获取读锁&quot;</span>);</span><br><span class="line">           </span><br><span class="line">           readWriteLock.readLock().unlock();</span><br><span class="line">           System.out.println(<span class="string">&quot;释放写锁&quot;</span>);</span><br><span class="line">           </span><br><span class="line">           readWriteLock.writeLock().unlock();</span><br><span class="line">           System.out.println(<span class="string">&quot;释放读锁&quot;</span>); </span><br><span class="line">       &#125;);</span><br><span class="line">       thread.start();</span><br><span class="line">       thread.join();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/*Output</span></span><br><span class="line"><span class="comment">       获取写锁</span></span><br><span class="line"><span class="comment">       获取读锁</span></span><br><span class="line"><span class="comment">       释放写锁</span></span><br><span class="line"><span class="comment">       释放读锁</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>锁降级还是有很多应用场景的。比如有业务需要先查缓存，发现缓存失效需要重新去数据库查询数据并修改缓存，完成修改操作后应该尽快释放写锁，减小锁的粒度。这样能让更多的读线程尽快访问到修改后的数据。不然业务逻辑半天执行不完，这期间尽管缓存数据是最新的，但是由于写锁未释放，其他线程也无法进行读操作。极大的降低了并发性。</p>
<p>因此在完成修改缓存后去拿读锁，然后释放写锁，这样既能保证其他线程读取到最新的数据，又能保证当前线程的后续操作使用的数据是最新的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> readWriteLock.writeLock();</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> cacheValid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processCachedData</span><span class="params">()</span> &#123;</span><br><span class="line">        r.lock();           <span class="comment">//获取读锁</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid)&#123;   <span class="comment">//缓存失效</span></span><br><span class="line">            r.unlock();     <span class="comment">//先释放读锁，不允许锁升级</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cacheValid)&#123;   <span class="comment">//再次检查缓存状态，</span></span><br><span class="line"><span class="comment">//                  cache= ...</span></span><br><span class="line">                    cacheValid =<span class="literal">true</span>;   <span class="comment">//完成缓存更新</span></span><br><span class="line">                &#125;</span><br><span class="line">                r.lock();   <span class="comment">//释放写锁前，降级为读锁</span></span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                w.unlock(); <span class="comment">//释放写锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//            ...     //执行业务逻辑</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-写锁支持条件变量"><a href="#2-2-写锁支持条件变量" class="headerlink" title="2.2 写锁支持条件变量"></a>2.2 写锁支持条件变量</h3><p><font color=cirmson>读锁不支持条件变量</font>，如果读锁调用newCondition（）会抛出UnsupportedOperationException异常；</p>
<p><font color=dodgerblue>写锁支持条件变量</font>，锁与条件变量的搭配使用可以参考上一篇 <a href="">Lock &amp; Condition</a>。</p>
<h2 id="3-ReentrantReadWriteLock原理"><a href="#3-ReentrantReadWriteLock原理" class="headerlink" title="3.ReentrantReadWriteLock原理"></a>3.ReentrantReadWriteLock原理</h2><p>ReentrantReadWriteLock内部还是使用的AQS框架，通过前面的学习我们知道，在AQS中，通过<code>volatile int state </code>来表示线程锁的状态，ReentrantReadWriteLock有两把锁：读锁和写锁，它们保护的都是同一个资源，如何用一个共享变量来区分写锁和读锁的状态呢？答案就是按位拆分。</p>
<p><img src="http://pic.networkcv.top//network/20200503/PrRPIbFByS7k.jpg?imageslim" alt="mark"></p>
<p>由于state是int类型的变量，在内存中占用4个字节，也就是32位。将其拆分为两部分：高16位和低16位，其中高16位用来表示读锁状态，低16位用来表示写锁状态。这样就可以用一个int变量来表示两种锁的状态，低16位写锁的加锁和释放锁操作不会发生变化，仍是state+1&#x2F;state-1；但高16位的加锁和释放锁就变成了state +  (1&lt;&lt;16)&#x2F; state-(1&lt;&lt;16)。</p>
<p>同样获取读锁和写锁的状态也有所不同：</p>
<p>获取读锁：<code>state &gt;&gt;&gt; 16</code>	无符号右移16位，空的地方补0。</p>
<p>获取写锁：<code>state  &amp; [(1 &lt;&lt; 16) - 1]</code> 相当于state &amp; 0x0000FFFF  相当于把高16位置空，只保留低16位。</p>
<p>由于读锁和写锁的状态值都只占用16位，所以读锁和写锁各自可重入锁的最大数量为2^16-1。</p>
<p>前面说了持有锁状态表示的问题，现在来看看其具体的实现。在此之前先了解一下ReentrantReadWriteLock的类结构。</p>
<p>ReentrantReadWriteLock中有两个内部类，ReadLock和WriteLock，这两个类在具体实现Lock接口时，分别调用ReentrantReadWriteLock中实现AQS类的同步组件Sync的共享和独占两种加锁释放锁方式来实现各自的功能。</p>
<p>Sync中实现AQS中独占锁加锁tryAcquire（）和独占锁释放锁tryRelease（），以及共享锁的加锁tryAcquireShared（）和共享锁的释放锁tryReleaseShared（）。</p>
<p>下面的内容也是围绕这四个方法展开。</p>
<h3 id="3-1-写锁加锁"><a href="#3-1-写锁加锁" class="headerlink" title="3.1 写锁加锁"></a>3.1 写锁加锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough</span></span><br><span class="line"><span class="comment">             * 1. 如果读锁或者写锁其中有一个不为0，而且锁的持有者不是线程，</span></span><br><span class="line"><span class="comment">             *	  尝试获取锁失败，该方法返回false。</span></span><br><span class="line"><span class="comment">             * 2. 如果加锁的数量满了，返回false。</span></span><br><span class="line"><span class="comment">             * 3. 另外，重复获取或者入口等待队列允许的线程才有资格加锁，</span></span><br><span class="line"><span class="comment">             *    修改state和锁的持有者</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    		<span class="comment">//返回state，高16代表读锁的数量，低16代表写锁的数量。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    		<span class="comment">//返回独占锁(也就是写锁)的数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">    		<span class="comment">//只有读锁和写锁有一个数量不为0，state就不为0，如果state为0，</span></span><br><span class="line">    		<span class="comment">//那么没有一个线程当前在使用读写锁，可以直接让当前线程去拿写锁</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                1.写锁数量为0，且独占锁不是被当前线程占用，那么一定是读锁的数量不为0，</span></span><br><span class="line"><span class="comment">                  说明读锁在使用，尝试获取锁失败，对应前边提到读写锁的基本原则：</span></span><br><span class="line"><span class="comment">                  如果一个线程在读，同样也禁止写共享变量。</span></span><br><span class="line"><span class="comment">               	  </span></span><br><span class="line"><span class="comment">                2.写锁不为0，但是独占锁的持有线程不是当前线程，说明其他线程在使用写锁</span></span><br><span class="line"><span class="comment">                  独占锁是互斥的，所以也会返回false。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//判断一下重入锁的次数会不会超过2^16-1</span></span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="comment">/* 这里设置state时没有使用CAS，原因很简单，能走到这里的必然是</span></span><br><span class="line"><span class="comment">                 	已经持有独占锁的线程来重入锁，其他情况无法通过前边的状态判断。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    		<span class="comment">/*state=0才能走到此处，writerShouldBlock()是用来判断是否需要排队</span></span><br><span class="line"><span class="comment">    		非公平锁：</span></span><br><span class="line"><span class="comment">    			直接返回false，然后使用CAS来修改state，如果修改成功则说明拿到锁了</span></span><br><span class="line"><span class="comment">    			那么可以继续将独占锁的持有线程设置为当前线程。</span></span><br><span class="line"><span class="comment">    		公平锁：</span></span><br><span class="line"><span class="comment">    			公平锁会调用hasQueuedPredecessors()，这个方法是判断入口等待队列</span></span><br><span class="line"><span class="comment">    			中是否有线程在等待锁。如果没有线程等待或者等待队列中排在最前边的是当前</span></span><br><span class="line"><span class="comment">    			线程，那么可以继续进行后边的CAS操作，否则返回false。</span></span><br><span class="line"><span class="comment">    		*/</span></span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//返回false的后续操作在下边</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>下面附上tryAcquire()的流程图：<br><img src="http://pic.networkcv.top//network/20200503/lzYbKXmICikg.jpg?imageslim" alt="mark"></p>
<p>tryAcquire返回false的后续操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">//如果tryAcquire()返回false，会继续往下执行。</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">//这行代码是在AQS中实现的，具体步骤为把当前线程封装为一个独占锁节点，</span></span><br><span class="line">        <span class="comment">//并加入到等待队列中，然后将当前线程阻塞</span></span><br><span class="line">        <span class="comment">//在阻塞前还会当前线程还会再尝试一次，是否能获取到锁，</span></span><br><span class="line">        <span class="comment">//这次尝试时，当前线程已经在等待队列中了，这个是acquireQueued()的内容。</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-写锁释放"><a href="#3-2-写锁释放" class="headerlink" title="3.2 写锁释放"></a>3.2 写锁释放</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;<span class="comment">//realeases=1</span></span><br><span class="line">    <span class="comment">//判断当前线程是否持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">     <span class="comment">//realease是这次调用要释放持有的锁的个数，比如之前重入了3次，</span></span><br><span class="line">     <span class="comment">//getState()返回3，releases=1，则本次释放1次，后边还需要再释放2次</span></span><br><span class="line">     <span class="comment">//只有state为0时才算彻底释放锁，独占锁的所有线程才会置为null</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">//检查是否是彻底释放锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//是彻底释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        <span class="comment">//独占锁的所有线程才会置为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">     <span class="comment">//同样没用CAS，因为 if (!isHeldExclusively()),只有当前线程可以通过</span></span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-读锁加锁"><a href="#3-3-读锁加锁" class="headerlink" title="3.3 读锁加锁"></a>3.3 读锁加锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">          <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    		<span class="comment">//如果不是当前线程占用写锁则会返回-1，表示共享锁加锁失败</span></span><br><span class="line">    		<span class="comment">//如果是当前线程占用写锁，再申请读锁，则是被允许的，这是锁降级的过程。</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    		<span class="comment">//获取读锁的数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">    		<span class="comment">//这里又是公平锁和非公平的一个区别。</span></span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;		<span class="comment">//判断是否需要阻塞</span></span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123; <span class="comment">//读锁+1</span></span><br><span class="line">                <span class="comment">//r=0，代表读锁没被占用，下边的操作对应写(独占)锁的话则是</span></span><br><span class="line">                <span class="comment">//设置写锁的持有者为当前线程，但是读锁是共享的，所以不能这样设置</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/*共享锁会为每个获取ReadLock的线程创建一个HoldCounter来记录该线程</span></span><br><span class="line"><span class="comment">                    的线程ID和获取ReadLock的次数(包括重入)。并将这个HoldCounter对象</span></span><br><span class="line"><span class="comment">                    保存在线程自己的ThreadLocal中。</span></span><br><span class="line"><span class="comment">                    ThreadLocalHoldCounter readHolds;</span></span><br><span class="line"><span class="comment">                    HoldCounter cachedHoldCounter;</span></span><br><span class="line"><span class="comment">                    </span></span><br><span class="line"><span class="comment">                    static final class ThreadLocalHoldCounter</span></span><br><span class="line"><span class="comment">                        extends ThreadLocal&lt;HoldCounter&gt; &#123;</span></span><br><span class="line"><span class="comment">                        public HoldCounter initialValue() &#123;</span></span><br><span class="line"><span class="comment">                            return new HoldCounter();</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    static final class HoldCounter &#123;</span></span><br><span class="line"><span class="comment">                        int count = 0;</span></span><br><span class="line"><span class="comment">                        // Use id, not reference, to avoid garbage retention</span></span><br><span class="line"><span class="comment">                        final long tid = getThreadId(Thread.currentThread());</span></span><br><span class="line"><span class="comment">				  &#125;</span></span><br><span class="line"><span class="comment">                    </span></span><br><span class="line"><span class="comment">                    设计者考虑到有些场景只有一个线程获取读锁，那么使用ThreadLocal</span></span><br><span class="line"><span class="comment">                    反而会降低性能，所以在ReentrantReadWriteLock中定义了：</span></span><br><span class="line"><span class="comment">                    private transient Thread firstReader = null;</span></span><br><span class="line"><span class="comment">                    private transient int firstReaderHoldCount;</span></span><br><span class="line"><span class="comment">                    来提供只有一个线程获取读锁的性能保障。</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    <span class="comment">//当前线程重入读锁</span></span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//多个线程来申请读锁时会到这一步,默认会从cachedHoldCounter中拿</span></span><br><span class="line">                    <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">                    <span class="comment">//如果rh.tid == getThreadId(current)，说明这个线程连续两次来拿读锁</span></span><br><span class="line">                    <span class="comment">//如果不等的话,则说明缓存失效了,需要重新从ThreadLocal取出HoldCounter</span></span><br><span class="line">                    <span class="comment">//顺便修改缓存</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="comment">//上一次拿读锁的是别的线程，这个线程是第一次来拿读锁</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取读锁成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    		<span class="comment">//在readerShouldBlock()返回true时，或者CAS修改失败时走到这里</span></span><br><span class="line">    		<span class="comment">//在这个方法中会用自旋的方式一直获取读锁，中途写锁被其他线程持有会返回-1</span></span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>下面附上tryAcquireShared()的流程图：</p>
<p><img src="http://pic.networkcv.top//network/20200503/WayT3RsHtyyC.jpg?imageslim" alt="mark"></p>
<h3 id="3-4-读锁释放"><a href="#3-4-读锁释放" class="headerlink" title="3.4 读锁释放"></a>3.4 读锁释放</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    		<span class="comment">/*</span></span><br><span class="line"><span class="comment">    		前边介绍了firstReader、firstReaderHoldCount</span></span><br><span class="line"><span class="comment">    		和cachedHoldCounter、readHolds，这里就很容易理解了</span></span><br><span class="line"><span class="comment">    		减少线程持有读锁个数，如果彻底释放读锁，那么还会将</span></span><br><span class="line"><span class="comment">    		firstReader或readHolds置空。</span></span><br><span class="line"><span class="comment">    		*/</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                    firstReader = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    firstReaderHoldCount--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> rh.count;</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    readHolds.remove();</span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">                &#125;</span><br><span class="line">                --rh.count;</span><br><span class="line">            &#125;</span><br><span class="line">    		<span class="comment">//这里是自旋CAS释放读锁的操作, 因为可能其他的线程此刻也在进行 release操作</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="comment">//读锁是高16位，所以这里通过c-(1&lt;&lt;16)来释放读锁</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - SHARED_UNIT;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="comment">/*                    </span></span><br><span class="line"><span class="comment">                    这里是判断读锁有没有彻底被释放，如果完全释放，后边则会以传播的方式</span></span><br><span class="line"><span class="comment">                    唤醒后继节点中共享类型的节点，成功获取读锁时也会执行唤醒后续共享类型节点</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>前面提到的四个方法，是Doug Lea大神留给我们的主要的发挥空间，AQS中其他核心方法都无法重写。如果需要实现自定义的同步组件，那么对这四个方法必然要深入理解，然后根据组件特性来实现独占锁或共享锁。如ReentrantLock是独占锁，所以其内部只实现了tryAcquire（）和tryRelease（）。因此本篇着重介绍了ReentrantReadWriteLock实现AQS的具体细节，没有从AQS框架整体上展开，有些地方可能不太好理解，还希望大家多多谅解。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>在ReentrantReadWriteLock中实现了独占锁和共享锁两种方式，读锁是共享的，可以在没有写锁的时候被多个线程同时持有，并发地读数据；写锁是独占的，每次只能被一个线程持有，其他线程要想修改共享数据，则需要排队等待。获得了读锁的线程能够看到前一个释放的写锁所更新的内容。</p>
<p>理论上，读写锁比互斥锁允许对于共享数据更大程度的并发。与互斥锁相比，读写锁是否能够提高性能取决于读写数据的频率、读取和写入操作的持续时间以及读线程和写线程之间的竞争。</p>
<p>ReentrantReadWriteLock<font color=Crimson>不支持锁的升级</font>，但是<font color=dodgerblue>支持锁的降级</font>。</p>
<p>ReentrantReadWriteLock的<font color=cirmson>读锁不支持条件变量</font>，但<font color=dodgerblue>写锁支持条件变量。</font></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>&emsp;&emsp;《Java 并发编程实战》<br>&emsp;&emsp;《Java 编程思想(第4版)》<br>&emsp;&emsp;<a target="_blank" rel="noopener" href="https://juejin.im/post/5dc22993f265da4cf77c8ded">https://juejin.im/post/5dc22993f265da4cf77c8ded</a><br>&emsp;&emsp;<a target="_blank" rel="noopener" href="http://www.tianxiaobo.com/">http://www.tianxiaobo.com</a></p>
<p><strong>感谢阅读</strong>！</p>

        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Java/"># Java</a>
                    
                        <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"># 并发编程</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/07/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A08-Semaphore%20&%20AQS/">Java并发编程：08-Semaphore & AQS</a>
            
            
            <a class="next" rel="next" href="/2020/07/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A06-Lock%20&%20Condition/">Java并发编程：06-Lock & Condition</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <!-- <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> -->
    <div class="copyright">
        <!-- <span> welcome~</a></span> -->
    </div>
    <!-- 访问统计 -->
    <!-- <div class="powered-by">
        <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
            welcome~ <span id="busuanzi_value_site_pv"></span>
        </span>
    </div> -->
</footer>

    </div>
</body>
</html>
