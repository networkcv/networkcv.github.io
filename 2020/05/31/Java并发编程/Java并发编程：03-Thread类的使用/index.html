<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">





<title>Java并发编程：03-Thread类的使用 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.2.0"></head>
<!-- <a target="_blank" rel="noopener" href="https://github.com/networkcv" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style> -->
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Network Cavalry&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Network Cavalry&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Java并发编程：03-Thread类的使用</h1>
            
                <div class="post-meta">
                    

                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p><strong>前言</strong>：<br>前面大致了解了线程的创建和生命周期，线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。本篇通过对Thread类中方法的讲解来展示线程生命周期的变化，同时也会对Thread类本身进行理解。</p>
<p><strong>面试问题</strong></p>
<p>Q ：wait和sleep方法的区别？<br>Q ：为什么wait和notify&#x2F;notifyAll要定义在Object中？</p>
<h2 id="1-Thread中的属性"><a href="#1-Thread中的属性" class="headerlink" title="1.Thread中的属性"></a>1.Thread中的属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>  <span class="variable">daemon</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Interruptible blocker;</span><br><span class="line">    <span class="keyword">volatile</span> Object parkBlocker;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">threadStatus</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> priority;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MIN_PRIORITY</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NORM_PRIORITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_PRIORITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> UncaughtExceptionHandler uncaughtExceptionHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> UncaughtExceptionHandler defaultUncaughtExceptionHandler;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>name</strong> ：是表示Thread的名字，可以通过Thread类的构造器中的参数来指定线程名字，通过getName（）来获取线程的名称，建议根据任务或功能对线程进行合理命名，以便调试。    </p>
<p>&emsp;&emsp;<strong>dameon</strong> ：表示线程是否是守护线程,默认为false，守护线程是为非守护线程服务的，在后台默默的完成一些系统性的服务，比如垃圾回收线程，JIT线程，如果JVM中只剩守护线程，JVM会直接退出。守护线程的设置务必在线程启动前完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t=<span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>target</strong> ：用来存放需要执行的任务。也就是构造方法中传入的Runnable实现，FutureTask也会存在这里。    </p>
<p>&emsp;&emsp;<strong>blocker</strong> ：中断标志位，用于判断是否被中断，中断可以理解为打断，如果需要停止一个正在执行任务的线程，可以通过线程的实例方法interrupt（）或者Thread.interrupted（）来设置其中断标志。</p>
<p>&emsp;&emsp;<strong>parkBlocker</strong> ：和中断标志位类似，不过修改这个状态的方法不在Threa中，而是通过JUC包下的LockSupport来操作。</p>
<p>&emsp;&emsp;<strong>threadStatus</strong> ：线程当前的状态。NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING和TERMINATED。</p>
<p>&emsp;&emsp;<strong>priority</strong> ：表示线程的优先级，优先级不是谁先谁后，而是权重，优先级高的线程更容易抢到cpu时间片,优先级分为1-10共10个等级，1表示最低优先级，5是默认级别。setPriority()用来设定线程的优先级，需要在线程start（）调用之前进行设定。  </p>
<p>&emsp;&emsp;<strong>uncaughtExceptionHandler</strong> ：未捕获异常的处理器，由于线程的本质特性，无法在当前线程捕获到从其他线程中逃逸的异常，一旦异常逃逸出run方法，它就会向外传播到控制台，而我们通常需要记录异常日志,所以就需要对线程做运行时的异常处理可以使用实例方法setUncaughtExceptionHandler() 来配置未捕获异常处理器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//不能捕获到其他线程的异常，所以下面这行代码不会被打印</span></span><br><span class="line">        System.out.println(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyUnCatchExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is MyUnCatchExceptionHandler &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;catch &quot;</span> + e + <span class="string">&quot; 记录日志&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过对线程实例设置unCaughtExceptionHandler,</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">MyUnCatchExceptionHandler</span>());</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;JDK5 之后可以使用Executor的ThreadFactory来解决这个问题,通过给 Thread实例 设置一个(实现 UnCatchExceptionHandler接口)未捕获异常处理器，也可以使用 Thread.setDefaultUnCatchExceptionHandler() 来配置默认的未捕获异常处理器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过在ThreadFactory中设置defaultUnCatchExceptionHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">cachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool(<span class="keyword">new</span> <span class="title class_">MyThreadFactory</span>());</span><br><span class="line">    cachedThreadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        <span class="comment">//thread.setUncaughtExceptionHandler(new MyUnCatchExceptionHandler());</span></span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">MyUnCatchExceptionHandler</span>());</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<strong>defaultUncaughtExceptionHandler</strong> :Thread类提供的默认未捕获异常的处理器。</p>
<h2 id="2-Thread中的方法"><a href="#2-Thread中的方法" class="headerlink" title="2.Thread中的方法"></a>2.Thread中的方法</h2><p>&emsp;&emsp;通过Thread中的属性，大致了解了Thread类的结构，下面我们通过线程状态转换图来学习Thread类中的方法。  </p>
<p><img src="http://pic.networkcv.top//network/20200503/dG5HPv8YvDwn.jpg?imageslim" alt="mark"></p>
<h3 id="2-1-start-、run-和stop"><a href="#2-1-start-、run-和stop" class="headerlink" title="2.1 start()、run()和stop()"></a>2.1 start()、run()和stop()</h3><p>&emsp;&emsp;在我们实例化一个Thread对象后，这个对象处于初始状态，也就是threadStatus为NEW，此时这个对象只是堆中的一个普通Java对象，虽然被称为线程对象，但其实在操作系统中并没有与之对应的线程，只有当调用该对象的start，操作系统才会创建一个新线程，我们可以通过断点进行查看。  </p>
<p>在执行thread.start()之前</p>
<p><img src="http://pic.networkcv.top//network/20200503/WpsOSsWQ2J2m.jpg?imageslim" alt="mark"></p>
<p>在执行thread.start()之后</p>
<p><img src="http://pic.networkcv.top//network/20200503/8aoAwsQnPyb3.jpg?imageslim" alt="mark"></p>
<p>&emsp;&emsp;Java的线程是不允许启动两次的，第二次调用会抛出IllegalThreadStateException，这是一种运行时异常。</p>
<p>&emsp;&emsp;run()不需要我们手动调用，通过start()方法启动线程之后，当线程获得CPU执行时间，便进入run()方法体去执行具体的任务。直接调用run方法会被当前线程当作一次普通的方法调用，归属于当前的线程栈。  </p>
<p>&emsp;&emsp;在run()方法正常执行完成后，线程会处于终止状态。但也总是会有例外情况，如果需要提前终止一个正在运行的线程，可以使用interrupt 方式或者stop()方法：  </p>
<ul>
<li><p>(1) 使用stop方法强行终止线程，<strong>不推荐使用</strong>，stop会立即释放掉该线程所持有的锁，可能无法正常释放自己所持有的资源，造成未知错误。如果修改了一半就被stop掉，那数据也只会被修改一半，可能产生不可预料的结果； </p>
</li>
<li><p>(2) 使用interrupt的方式，interrupt()方法并未真正停止线程，只不过在线程中修改了blocker标记，此时可以使用抛异常的方式使线程停止。</p>
</li>
</ul>
<p>&emsp;&emsp;windows的线程是抢占式的，意味着线程可以强制结束其他线程，例如通过任务管理器结束一个无响应的应用程序。<br>Java的线程工作方式是协作式，这样设计是为了让线程自身能够在线程关闭前处理自己的数据。</p>
<h3 id="2-2-suspend-和resume"><a href="#2-2-suspend-和resume" class="headerlink" title="2.2 suspend()和resume()"></a>2.2 suspend()和resume()</h3><p><strong>不推荐使用</strong><br>&emsp;&emsp;如果想让一个线程暂停执行，而不是终止这个线程，可以使用suspend()将线程挂起，需要线程继续执行时使用resume()。正常情况下是先suspend()再resume()，如果将这两个方法的调用顺序调换，那么线程将永远被挂起，并且suspend()不会释放锁，这种情况下则会发生死锁。而且被suspend挂起的线程状态显示为”RUNNABLE”状态，这给排查bug带来困难。<br>&emsp;&emsp;因此在JUC中提供了LockSupport类来代替suspend()和resume()，可以看到线程状态转换图中的LockSupport.park()和LockSupport.unpark(),后面会的对LockSupport的实现进行详细的讲解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    TimeUnit.NANOSECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//先挂起再继续执行</span></span><br><span class="line">    thread.resume();</span><br><span class="line">    thread.suspend();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"><span class="comment">// 这种情况程序会一直执行，不停的打印i的值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    TimeUnit.NANOSECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//先继续执行再挂起</span></span><br><span class="line">    thread.suspend();</span><br><span class="line">    thread.resume();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"><span class="comment">// 这种情况线程会被挂起，控制台只会显示在挂起前打印的值，</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-sleep-和TimeUnit"><a href="#2-3-sleep-和TimeUnit" class="headerlink" title="2.3 sleep()和TimeUnit"></a>2.3 sleep()和TimeUnit</h3><p>&emsp;&emsp;static sleep(long millis) 的作用是当前正在执行的线程睡眠一段时间，出 CPU 让其去执行其他的任务，睡眠结束后获取到时间片才会继续执行任务。<br>&emsp;&emsp;调用sleep()，会抛出编译期异常InterruptedException，你需要捕获或者将该异常继续上抛。sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，其他线程无法访问这个对象。由于sleep(long millis)中控制睡眠时长的单位是毫秒级，这样可读性比较差，建议使用TimeUnit：</p>
<ul>
<li>TimeUnit.DAYS 日的工具类 </li>
<li>TimeUnit.HOURS 时的工具类 </li>
<li>TimeUnit.MINUTES 分的工具类 </li>
<li>TimeUnit.SECONDS 秒的工具类 </li>
<li>TimeUnit.MILLISECONDS 毫秒的工具类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//休眠一天</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>);</span><br><span class="line">    TimeUnit.DAYS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-4-interrupt-、isInterrupted-和Thread-interrupted"><a href="#2-4-interrupt-、isInterrupted-和Thread-interrupted" class="headerlink" title="2.4 interrupt()、isInterrupted()和Thread.interrupted()"></a>2.4 interrupt()、isInterrupted()和Thread.interrupted()</h3><p>&emsp;&emsp;Java没有提供任何机制来安全的终止线程，但它提供了<strong>中断</strong>（Interruption），这是一种协作机制，能够使一个线程终止另一个线程的当前工作。我们很少希望某个任务、线程或服务立即停止，因为这种立即停止会使共享的数据结构处于不一致的状态。通过协作的方式，我们可以让要退出的程序清理当前正在执行的工作，然后再结束，这提供了更好的灵活性，因为任务本身的代码比发出取消请求的代码更清楚如何清除工作。<br>&emsp;&emsp;Java通过协作式中断，通过推迟中断请求的处理，开发人员能制定更灵活的中断策略，使程序在响应性和健壮性之间实现合理的平衡。需要使用中断的方法都要求抛出或捕获处理InterruptedException异常。</p>
<p><strong>interrupt()</strong><br>&emsp;&emsp;设置中断状态为true，如果线程处于就绪状态则不会直接中断，而是将线程状态改为中断状态，需要手动去检测线程的中断状态，如果线程被阻塞则能抛出InterruptedException异常，当抛出InterruptedException异常或者调用Thread.interrupted()时，中状态将被复位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误写法  虽然将线程设置为中断状态，但内部程序一直在执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//线程处于就绪状态</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">thred.interrupt()</span><br><span class="line"></span><br><span class="line"><span class="comment">//当线程被中断后，会执行完当前的操作后，进入下一轮循环的时候停止</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Interrupted!&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">thred.interrupt()</span><br></pre></td></tr></table></figure>

<p><strong>isInterrupted()</strong><br>判断线程是否被中断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//不清除中断状态</span></span><br><span class="line">  <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>Thread.interrupted()</strong><br>判断是否被中断，并清除当前中断状态，实现Runnable接口的只能调用这个方法。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> Thread.interrupted()&#123; </span><br><span class="line">  <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>无法响应中断的阻塞</strong></p>
<ul>
<li><p>执行同步的SocketI&#x2F;O无法响应中断。  </p>
</li>
<li><p>InputStream和OutputStream的read和write等方法都不会响应中断，但可以通过关闭底层的套接字，使因read或write等方法被阻塞的线程抛出一个SocketException。  </p>
</li>
<li><p>等待获得内置锁（synchronized）而阻塞，无法响应中断。但使用Lock类中提供了lockInterruptibly方法，该方法允许在等待一个锁的同时仍能响应中断。</p>
</li>
</ul>
<h3 id="2-5-wait-和notify-notifyAll"><a href="#2-5-wait-和notify-notifyAll" class="headerlink" title="2.5 wait()和notify()&#x2F;notifyAll()"></a>2.5 wait()和notify()&#x2F;notifyAll()</h3><p>调用这三个方法的前提是调用者持有锁，不然会抛出IllegalMonitorStateException异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    lock.wait();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    lock.notify();</span><br><span class="line">    lock.notifyAll();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>wait()</strong> 会释放当前持有的锁，让出CPU，使线程进入等待状态。<br>&emsp;&emsp;<strong>notify()</strong> 唤醒一个等待该锁的线程，然后继续执行，直至退出临界区（锁住notify()的区域），锁才会被释放，等待该锁的线程才能去抢锁。<br>&emsp;&emsp;<strong>notifyAll()</strong> 唤醒所有在对象锁上等待的线程。  </p>
<p>之前展示的所有方法都是定义在Thread中的，但是这三个被定义在Object对象中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么 wait() 和notify() &#x2F; notifyAll() 方法要放在同步块中？</strong></p>
<p>&emsp;&emsp;在多线程环境下有著名问题“Lost wake-up”。线程进入等待状态后，丢失了唤醒操作，导致线程永远处于等待状态。<br>假如有两个线程，一个消费者线程，一个生产者线程。生产者线程的任务生产商品简化为count+1，而后唤醒消费者；消费者则是判断有无商品，有则消费商品，无则进入等待。  </p>
<p><img src="http://pic.networkcv.top//network/20200503/LQeaNYXTa95q.jpg?imageslim" alt="mark"></p>
<p>&emsp;&emsp;在消费者执行的过程中，先判断了count的状态，随后发生上下文切换，生产者执行了全部操作，由于消费者还没有进入等待状态，所以生产者的notify没有任何作用，于是在此处唤醒操作就丢失了。执行权切换到消费者，继续执行，但此时的count已经被修改为1，所以之前的判断失效，消费者没有重新判断count状态，就继续执行，进入等待后没有唤醒操作，导致无限制等待。</p>
<p>&emsp;&emsp;问题的根源在于，消费者在检查count到调用wait()之间，count就可能被改掉了。这就是一种最常见的竞态条件“先检查后执行(check-Then-Act)”。还有一种常见的是“读取-修改-写入”，为了确保线程安全性，这类复合操作必须以原子方式执行来确保线程的安全性，synchronized是Java提供的内置锁，它可以保证一组操作的原子性，应用在刚才的场景下就是，检查count和调用wait()之间，count不会修改。这样才能避免“Lost Weak-up”问题的发生。因此wait()必须在同步块中调用。</p>
<p><strong>为什么 wait() 和notify() &#x2F; notifyAll() 方法定义在Object而不是Thread类中？</strong> </p>
<p>&emsp;&emsp;通过上一个问题我们了解到wait和notify执行的前提是需要持有锁，而Java中锁可以是任意的对象，所以这三个方法定义在Object中。</p>
<p><strong>sleep() 方法和 wait() 方法区别?</strong></p>
<ul>
<li>sleep不会释放锁，使得线程仍然可以同步控制；wait会释放锁，进入线程等待池中等待。</li>
<li>sleep可以在任何地方使用；wait&#x2F;notify&#x2F;notifyAll只能在同步控制方法或者同步控制块中使用。</li>
<li>sleep通常被用于暂停执行；wait通常被用于线程间交互。</li>
<li>sleep是Thread类中的方法；wait是Object类中的方法。</li>
<li>sleep会自动唤醒，如果想要提前唤醒，可以使用interrupt方法中断；调用wait()方法的线程，不会自己唤醒，需要线程调用notify&#x2F;notifyAll方法唤醒。</li>
</ul>
<h3 id="2-6-yeild-和join"><a href="#2-6-yeild-和join" class="headerlink" title="2.6 yeild()和join()"></a>2.6 yeild()和join()</h3><p><strong>yeild()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当一个线程拿到CPU时间片后，调用yeild()方法使得线程交出当前时间片，重新与拥有相同优先级或更高优先级的线程竞争，竞争成功后还是会执行的，yield()方法不能控制具体的交出，只能让其他线程有更多获取 CPU 执行时间的机会，yeild不会释放锁。<br>&emsp;&emsp;yield()方法会增加发生上下文切换的概率，并发调试的时候更容易将问题暴露出来。</p>
<p><strong>sleep与yield的区别</strong></p>
<ul>
<li>sleep方法给其它线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield方法只会给相同或更高优先级的线程以运行的机会。</li>
<li>sleep方法之后转入阻塞状态；yield方法之后转入就绪状态。</li>
<li>sleep方法声明抛出InterruptedException；yield方法没有声明任何异常。</li>
<li>sleep方法具有更好的可移植性且sleep更容易被控制；（yield不好控制，只是瞬间放弃CPU的执行权，有可能马上又抢回接着执行）。</li>
<li>sleep和yield方法将在当前正在执行的线程上运行，所以在其它处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。</li>
</ul>
<p><strong>join()</strong><br>可以理解为等待一个线程执行结束，先看一个简单的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程执行结束&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();  </span><br><span class="line">    <span class="comment">//等待thread线程执行完成或者抛出异常，在等待期间执行这行代码的线程是阻塞的</span></span><br><span class="line">    System.out.println(<span class="string">&quot;...&quot;</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//Output</span></span><br><span class="line">        3s后打印</span><br><span class="line">    <span class="comment">// 线程执行结束</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java中提供了3种join的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        join(<span class="number">0</span>);    <span class="comment">//调用无参join则会一直等待,直至线程执行结束</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);    <span class="comment">//join的通过调用wait()实现，因此join会释放锁</span></span><br><span class="line">                            <span class="comment">//线程执行完毕后，系统会调用notifyAll()  </span></span><br><span class="line">                            <span class="comment">//因此建议不要在Thread实例上使用wait()和notify()  </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span></span><br><span class="line">                                      <span class="keyword">throws</span> InterruptedException &#123;...</span><br></pre></td></tr></table></figure>


<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>&emsp;&emsp;《Java 并发编程实战》<br>&emsp;&emsp;《Java 编程思想(第4版)》<br>&emsp;&emsp;<a target="_blank" rel="noopener" href="https://blog.csdn.net/justloveyou_/article/details/54347954">https://blog.csdn.net/justloveyou_/article/details/54347954</a><br>&emsp;&emsp;<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35508033/article/details/89299305">https://blog.csdn.net/qq_35508033/article/details/89299305</a></p>
<p><strong>感谢阅读</strong>！</p>

        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Java/"># Java</a>
                    
                        <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"># 并发编程</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/07/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A04-Javan%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java并发编程：04-Javan内存模型</a>
            
            
            <a class="next" rel="next" href="/2020/05/31/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A02-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Java并发编程：02-线程的生命周期</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <!-- <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> -->
    <div class="copyright">
        <!-- <span> welcome~</a></span> -->
    </div>
    <!-- 访问统计 -->
    <!-- <div class="powered-by">
        <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
            welcome~ <span id="busuanzi_value_site_pv"></span>
        </span>
    </div> -->
</footer>

    </div>
</body>
</html>
